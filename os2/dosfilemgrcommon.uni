module dosfilemgrcommon;

uses hevdef;

   (*** File manager *)
   (* DosSetFilePtr() file position codes *)

   const FILE_BEGIN    =  $0000;   (* Move relative to beginning of file *)
   const FILE_CURRENT  =  $0001;   (* Move relative to current fptr position *)
   const FILE_END      =  $0002;   (* Move relative to end of file *)
   const FILE_SECTOR   =  $8000;   (* Interpret offset as a sector *)

   (* DosListIO() operation flags   *)

   const LISTIO_READ   =  $0004;  (* perform seek/read *)
   const LISTIO_WRITE  =  $0008;  (* perform seek/write *)

   (* DosListIO() operation modes  *)

   const LISTIO_ORDERED   = $0001;  (* guarantee ordering of operations *)
   const LISTIO_UNORDERED = $0002;  (* speed is king *)

   (* DosFindFirst/Next Directory handle types *)
   const HDIR_SYSTEM     =   1;     (* Use system handle (1) *)
   const HDIR_CREATE     = (-1);    (* Allocate a new, unused handle *)

   (* DosCopy control bits; may be or'ed together *)
   const DCPY_EXISTING  = $0001;   (* Copy even if target exists *)
   const DCPY_APPEND    = $0002;   (* Append to existing file, do not replace *)
   const DCPY_FAILEAS   = $0004;   (* Fail if EAs not supported on target*)

   (* DosOpen/DosQFHandState/DosQueryFileInfo et al file attributes; also *)
   (* known as Dos File Mode bits... *)
   const FILE_NORMAL    = $0000;
   const FILE_READONLY  = $0001;
   const FILE_HIDDEN    = $0002;
   const FILE_SYSTEM    = $0004;
   const FILE_DIRECTORY = $0010;
   const FILE_ARCHIVED  = $0020;

   const FILE_IGNORE    = $10000;     (* ignore file attribute in *)
   (* DosSetPath/File Info if *)
   (* this bit is set*)

   const MUST_HAVE_READONLY  =    ( (FILE_READONLY  shl 8) or FILE_READONLY  );
   const MUST_HAVE_HIDDEN    =    ( (FILE_HIDDEN    shl 8) or FILE_HIDDEN    );
   const MUST_HAVE_SYSTEM    =    ( (FILE_SYSTEM    shl 8) or FILE_SYSTEM    );
   const MUST_HAVE_DIRECTORY =    ( (FILE_DIRECTORY shl 8) or FILE_DIRECTORY );
   const MUST_HAVE_ARCHIVED  =    ( (FILE_ARCHIVED  shl 8) or FILE_ARCHIVED  );

   (* DosOpen() actions *)
   const FILE_EXISTED   = $0001;
   const FILE_CREATED   = $0002;
   const FILE_TRUNCATED = $0003;

   (* DosOpen() open flags *)
   const FILE_OPEN      = $0001;
   const FILE_TRUNCATE  = $0002;
   const FILE_CREATE    = $0010;

   (*     this nibble applies if file already exists                xxxx *)
   const OPEN_ACTION_FAIL_IF_EXISTS    = $0000;  (* ---- ---- ---- 0000 *)
   const OPEN_ACTION_OPEN_IF_EXISTS    = $0001;  (* ---- ---- ---- 0001 *)
   const OPEN_ACTION_REPLACE_IF_EXISTS = $0002;  (* ---- ---- ---- 0010 *)

   (*     this nibble applies if file does not exist           xxxx      *)
   const OPEN_ACTION_FAIL_IF_NEW       = $0000;  (* ---- ---- 0000 ---- *)
   const OPEN_ACTION_CREATE_IF_NEW     = $0010;  (* ---- ---- 0001 ---- *)

   (* DosOpen/DosSetFHandState mode flags *)
   const OPEN_ACCESS_READONLY          = $0000;  (* ---- ---- ---- -000 *)
   const OPEN_ACCESS_WRITEONLY         = $0001;  (* ---- ---- ---- -001 *)
   const OPEN_ACCESS_READWRITE         = $0002;  (* ---- ---- ---- -010 *)
   const OPEN_SHARE_DENYREADWRITE      = $0010;  (* ---- ---- -001 ---- *)
   const OPEN_SHARE_DENYWRITE          = $0020;  (* ---- ---- -010 ---- *)
   const OPEN_SHARE_DENYREAD           = $0030;  (* ---- ---- -011 ---- *)
   const OPEN_SHARE_DENYNONE           = $0040;  (* ---- ---- -100 ---- *)
   const OPEN_FLAGS_NOINHERIT          = $0080;  (* ---- ---- 1--- ---- *)
   const OPEN_FLAGS_NO_LOCALITY        = $0000;  (* ---- -000 ---- ---- *)
   const OPEN_FLAGS_SEQUENTIAL         = $0100;  (* ---- -001 ---- ---- *)
   const OPEN_FLAGS_RANDOM             = $0200;  (* ---- -010 ---- ---- *)
   const OPEN_FLAGS_RANDOMSEQUENTIAL   = $0300;  (* ---- -011 ---- ---- *)
   const OPEN_FLAGS_NO_CACHE           = $1000;  (* ---1 ---- ---- ---- *)
   const OPEN_FLAGS_FAIL_ON_ERROR      = $2000;  (* --1- ---- ---- ---- *)
   const OPEN_FLAGS_WRITE_THROUGH      = $4000;  (* -1-- ---- ---- ---- *)
   const OPEN_FLAGS_DASD               = $8000;  (* 1--- ---- ---- ---- *)
   const OPEN_FLAGS_NONSPOOLED         = $00040000;
   const OPEN_SHARE_DENYLEGACY     =  $10000000;   (* 2GB *)
   const OPEN_FLAGS_PROTECTED_HANDLE = $40000000;


   (* DosSearchPath() constants *)
   const SEARCH_PATH          = $0000;
   const SEARCH_CUR_DIRECTORY = $0001;
   const SEARCH_ENVIRONMENT   = $0002;
   const SEARCH_IGNORENETERRS = $0004;


   (************************************************************
   EA Info Levels & Find First/Next
   =========================================
   API's: DosFindFirst, DosQueryFileInfo, DosQueryPathInfo, DosSetFileInfo,
   DosSetPathInfo
   ************************************************************)

   (* File info levels *)
   const FIL_STANDARD          =  1;     (* Info level 1, standard file info *)
   const FIL_QUERYEASIZE       =  2;     (* Level 2, return Full EA size *)
   const FIL_QUERYEASFROMLIST  =  3;     (* Level 3, return requested EA's *)
   const FIL_STANDARDL         = 11;     (* LFS - Info level 11, standard file info for large files*)
   const FIL_QUERYEASIZEL      = 12;     (* LFS - Level 12, return Full EA size for large files *)
   const FIL_QUERYEASFROMLISTL = 13;     (* LFS - Level 13, return requested EA's *)


   (* File info levels: Dos...PathInfo only *)
   const FIL_QUERYFULLNAME    = 5;     (* Level 5, return fully qualified
   name of file *)


   (* DosFsAttach() *)
   (* Attact or detach *)
   const FS_ATTACH            = 0;     (* Attach file server *)
   const FS_DETACH            = 1;     (* Detach file server *)
   const FS_SPOOLATTACH       = 2;     (* Register a spooler device *)
   const FS_SPOOLDETACH       = 3;     (* De-register a spooler device *)


   (* DosFsCtl() *)
   (* Routing type *)
   const FSCTL_HANDLE         = 1;     (* File Handle directs req routing *)
   const FSCTL_PATHNAME       = 2;     (* Path Name directs req routing   *)
   const FSCTL_FSDNAME        = 3;     (* FSD Name directs req routing    *)

   (* defined FSCTL functions *)
   const FSCTL_ERROR_INFO           = 1;  (* return error info from FSD  *)
   const FSCTL_MAX_EASIZE           = 2;  (* Max ea size for the FSD     *)
   const FSCTL_GET_NEXT_ROUTE_NAME  = 3;  (* Rtrn next valid FSD name    *)
   const FSCTL_DAEMON_QUERY         = 4;  (* FSD query for daemon rqrmnt *)

   (* defined FSCTL query flags *)
   const FSCTL_QUERY_COMPLETE    = $0000;
   const FSCTL_QUERY_AGAIN       = $0001;

   type EASIZEBUF=structure      (* easizebuf struct for FSCTL fn 2  *)
                                (* max ea size                      *)
      cbMaxEASize: USHORT;        (* max. size of one EA              *)
      cbMaxEAListSize: ULONG;    (* max size of the full EA List     *)
   end;
   type PEASIZEBUF=EASIZEBUF;

   type ROUTENAMEBUF=structure (* routenamebuf struct for FSCTL fn 3 - return next FSD name *)
      hRouteHandle: ULONG;   (* Input- set to 0 for first name, use    *)
                              (*   the value returned for next name     *)
                              (* Output- handle to use to get next name *)
      szRouteName: UCHAR;    (* Registered FSD name that can be used   *)
                              (*   for FSCTL_FSDNAME routing type       *)
   end;
   type PROUTENAMEBUF=^ROUTENAMEBUF;

   (* Data associated with an FSD Daemon thread spawning action  *)

   type FSDTHREAD=structure  (* fsdthread struct for FSCTL fn 4 *)
      usFunc: USHORT;
      usStackSize: USHORT;
      ulPriorityClass: ULONG;
      lPriorityLevel: LONG;
   end;

   (* Data associated with an FSD Daemon thread requirements     *)
   type FSDDAEMON=structure  (* fsddaemon struct for FSCTL fn 4 *)
           usNumThreads: USHORT;
           usMoreFlag: USHORT;
           usCallInstance: USHORT;
           tdThrds:array[16] of FSDTHREAD;
   end;

   (* DosQueryFSAttach() *)
   (* Information level types (defines method of query) *)
   const FSAIL_QUERYNAME      = 1;     (* Return data for a Drive or Device *)
   const FSAIL_DEVNUMBER      = 2;     (* Return data for Ordinal Device # *)
   const FSAIL_DRVNUMBER      = 3;     (* Return data for Ordinal Drive # *)

   (* Item types (from data structure item "iType") *)
   const FSAT_CHARDEV         = 1;     (* Resident character device *)
   const FSAT_PSEUDODEV       = 2;     (* Pusedu-character device *)
   const FSAT_LOCALDRV        = 3;     (* Local drive *)
   const FSAT_REMOTEDRV       = 4;     (* Remote drive attached to FSD *)

   type FSQBUFFER=structure      (* fsqbuf Data structure for QFSAttach *)
      iType: USHORT;              (* Item type *)
      cbName: USHORT;             (* Length of item name, sans NULL *)
      szName:array[1] of UCHAR;          (* ASCIIZ item name *)
      cbFSDName: USHORT;          (* Length of FSD name, sans NULL *)
      szFSDName:array[1] of UCHAR;       (* ASCIIZ FSD name *)
      cbFSAData: USHORT;          (* Length of FSD Attach data returned *)
      rgFSAData:array[1] of UCHAR;       (* FSD Attach data from FSD *)
   end;
   type PFSQBUFFER=^FSQBUFFER;


   type FSQBUFFER2 =structure      (* fsqbuf2 Data structure for QFSAttach *)
      iType: USHORT;
      cbName: USHORT;
      cbFSDName: USHORT;
      cbFSAData: USHORT;
      szName:array[1] of UCHAR;
      szFSDName: array[1] of UCHAR;
      rgFSAData: array[1] of UCHAR ;
   end;
   type PFSQBUFFER2=^FSQBUFFER2;

   type SPOOLATTACH=structure      (* spool Data structure for spooler operations *)
      hNmPipe: USHORT;              (* Named pipe handle *)
      ulKey: ULONG;                (* Attached key *)
   end;
   type PSPOOLATTACH=^SPOOLATTACH;


   (*****************************************************************************
   * File System Drive Information&gml DosQueryFSInfo DosSetFSInfo              *
   *****************************************************************************)

   (* FS Drive Info Levels *)
   const FSIL_ALLOC           = 1;     (* Drive allocation info (Query only) *)
   const FSIL_VOLSER          = 2;     (* Drive Volum/Serial info *)

   (* DosQueryFHType() *)
   (* Handle classes (low 8 bits of Handle Type) *)
   const FHT_DISKFILE         = $0000;   (* Disk file handle *)
   const FHT_CHRDEV           = $0001;   (* Character device handle *)
   const FHT_PIPE             = $0002;   (* Pipe handle *)

   (* Handle bits (high 8 bits of Handle Type) *)
   const FHB_DSKREMOTE        = $8000;   (* Remote disk *)
   const FHB_CHRDEVREMOTE     = $8000;   (* Remote character device *)
   const FHB_PIPEREMOTE       = $8000;   (* Remote pipe *)


(*   type FTIME=USHORT;
   type FDATE=USHORT; *)


      (* File time and date types *)
         type FTIME=structure           (* ftime *)
            twosecs: USHORT; (* : 5; *)
            minutes: USHORT; (* : 6; *)
            hours: USHORT; (*  : 5; *)
         end;
         type PFTIME=^FTIME;

         type FDATE=structure           (* fdate *)
            day: USHORT;   (*  : 5;    *)
            month: USHORT; (*  : 4; *)
            year: USHORT;  (*  : 7; *)
         end;
         type PFDATE=^FDATE;


   type VOLUMELABEL=structure      (* vol *)
      cch: BYTE;
      szVolLabel:array[12] of CHAR;
   end;
   type PVOLUMELABEL=^VOLUMELABEL;

   type FSINFO=structure      (* fsinf *)
      fdateCreation: FDATE;
      ftimeCreation: FTIME;
      vol: VOLUMELABEL;
   end;
   type PFSINFO=^FSINFO;

   (* HANDTYPE values *)
   const HANDTYPE_FILE        = $0000;
   const HANDTYPE_DEVICE      = $0001;
   const HANDTYPE_PIPE        = $0002;
   const HANDTYPE_PROTECTED   = $4000;
   const HANDTYPE_NETWORK     = $8000;

   type FILELOCK=structure     (* flock *)
      lOffset: LONG;
      lRange: LONG;
   end;
   type PFILELOCK=^FILELOCK;

   (* Large File Support >2GB *)
   type FILELOCKL=structure     (* flock *)
       lOffset: LONGLONG;
       lRange: LONGLONG;
   end;
   type PFILELOCKL=^FILELOCKL;


   type    FHLOCK=ULONG;
   type    PFHLOCK=PULONG;

   function DosSetFileLocks(hFile: HFILE;
                                   pflUnlock:PFILELOCK;
                                   pflLock:PFILELOCK;
                                   timeout: ULONG;
                                   flags: ULONG): APIRET;

   (* Large File Support >2GB *)
function DosSetFileLocksL( hFile:HFILE;
                                     pflUnlock: PFILELOCKL;
                                     pflLock:PFILELOCKL;
                                     timeout:ULONG;
                                     flags:ULONG): APIRET;

function DosProtectSetFileLocks( hFile: HFILE;
                                           pflUnlock:PFILELOCK;
                                           pflLock: PFILELOCK;
                                           timeout:ULONG;
                                           flags: ULONG;
                                           fhFileHandleLockID: FHLOCK): APIRET;

   (* Large File Support >2GB *)
function DosProtectSetFileLocksL(hFile: HFILE;
                                            pflUnlock: PFILELOCKL;
                                            pflLock: PFILELOCKL;
                                            timeout: ULONG;
                                            flags: ULONG;
                                            fhFileHandleLockID: FHLOCK): APIRET;

function DosCancelLockRequest(hFile: HFILE; pflLock: PFILELOCK): APIRET;


   (* Large File Support >2GB *)
function DosCancelLockRequestL(hFile: HFILE; pflLock: PFILELOCKL): APIRET;


      type FILEFINDBUF=structure     (* findbuf *)
           fdateCreation: FDATE;
           ftimeCreation: FTIME;
           fdateLastAccess: FDATE;
           ftimeLastAccess: FTIME;
           fdateLastWrite: FDATE;
           ftimeLastWrite: FTIME;
           cbFile: ULONG;
           cbFileAlloc: ULONG;
           attrFile: USHORT;
           cchName: UCHAR;
           achName: array[CCHMAXPATHCOMP] of CHAR;
      end;

      type PFILEFINDBUF=^FILEFINDBUF;

      type FILEFINDBUF2=structure    (* findbuf2 *)
           fdateCreation: FDATE;
           ftimeCreation: FTIME;
           fdateLastAccess: FDATE;
           ftimeLastAccess: FTIME;
           fdateLastWrite: FDATE;
           ftimeLastWrite: FTIME;
           cbFile: ULONG;
           cbFileAlloc: ULONG;
           attrFile: USHORT;
           cbList: ULONG;
           cchName: UCHAR;
           achName: array[CCHMAXPATHCOMP] of CHAR;
      end;
      type PFILEFINDBUF2=^FILEFINDBUF2;

      type FILEFINDBUF3=structure                 (* findbuf3 *)
            oNextEntryOffset: ULONG;            (* new field *)
            fdateCreation: FDATE;
            ftimeCreation: FTIME;
            fdateLastAccess: FDATE;
            ftimeLastAccess: FTIME;
            fdateLastWrite: FDATE;
            ftimeLastWrite: FTIME;
            cbFile: ULONG;
            cbFileAlloc: ULONG;
            attrFile: ULONG;                    (* widened field *)
            cchName: UCHAR;
            achName: array[CCHMAXPATHCOMP] of CHAR;
      end;
      type PFILEFINDBUF3=^FILEFINDBUF3;

      type FILEFINDBUF4=structure                 (* findbuf4 *)
            oNextEntryOffset: ULONG;            (* new field *)
            fdateCreation: FDATE;
            ftimeCreation: FTIME;
            fdateLastAccess: FDATE;
            ftimeLastAccess: FTIME;
            fdateLastWrite: FDATE;
            ftimeLastWrite: FTIME;
            cbFile: ULONG;
            cbFileAlloc: ULONG;
            attrFile: ULONG;                    (* widened field *)
            cbList: ULONG;
            cchName: UCHAR;
            achName: array[CCHMAXPATHCOMP] of CHAR;
      end;
      type PFILEFINDBUF4=^FILEFINDBUF4;

      type FILEFINDBUF3L=structure                 (* findbuf3l *)
             oNextEntryOffset: ULONG;            (* new field *)
             fdateCreation: FDATE;
             ftimeCreation: FTIME;
             fdateLastAccess: FDATE;
             ftimeLastAccess: FTIME;
             fdateLastWrite: FDATE;
             ftimeLastWrite: FTIME;
             cbFile: LONGLONG;
             cbFileAlloc: LONGLONG;
             attrFile: ULONG;                    (* widened field *)
             cchName: UCHAR;
             achName: array[CCHMAXPATHCOMP] of CHAR;
      end;
      type PFILEFINDBUF3L=^FILEFINDBUF3L;

      type FILEFINDBUF4L=structure                (* findbuf4l *)
             oNextEntryOffset: ULONG;            (* new field *)
             fdateCreation: FDATE;
             ftimeCreation: FTIME;
             fdateLastAccess: FDATE;
             ftimeLastAccess: FTIME;
             fdateLastWrite: FDATE;
             ftimeLastWrite: FTIME;
             cbFile: LONGLONG;
             cbFileAlloc: LONGLONG;
             attrFile: ULONG;                    (* widened field *)
             cbList: ULONG;
             cchName: UCHAR;
             achName: array[CCHMAXPATHCOMP] of CHAR;
      end;
      type PFILEFINDBUF4L=^FILEFINDBUF4L;

      (* extended attribute structures *)

      type GEA=structure         (* gea *)
          cbName: BYTE;        (* name length not including NULL *)
          szName: array[1] of CHAR;     (* attribute name *)
      end;
      type PGEA=^GEA;

      type GEALIST=structure     (* geal *)
         cbList: ULONG;       (* total bytes of structure including full list *)
         list:array[1] of GEA;        (* variable length GEA structures *)
      end;
      type PGEALIST=^GEALIST;

      type FEA=structure         (* fea *)
          fEA: BYTE;           (* flags                              *)
          cbName: BYTE;        (* name length not including NULL *)
          cbValue: USHORT;     (* value length *)
      end;
      type PFEA=^FEA;

      (* flags for _FEA.fEA *)
      const FEA_NEEDEA     =    $80;     (* need EA bit *)

      type FEALIST=structure     (* feal *)
          cbList: ULONG;       (* total bytes of structure including full list *)
          list: array[1] of FEA;        (* variable length FEA structures *)
      end;
      type PFEALIST=^FEALIST;

      type EAOP=structure        (* eaop *)
          fpGEAList: PGEALIST; (* general EA list *)
          fpFEAList: PFEALIST; (* full EA list *)
          oError: ULONG;
      end;
      type PEAOP=^EAOP;

      type FEA2=structure         (* fea2 *)
            oNextEntryOffset: ULONG;    (* new field *)
            fEA: BYTE;
            cbName: BYTE;
            cbValue: USHORT;
            szName: array[1] of CHAR;           (* new field *)
      end;
      type PFEA2=^FEA2;


      type FEA2LIST=structure     (* fea2l *)
            cbList: ULONG;
            list: array[1] of FEA2;
      end;
      type PFEA2LIST=^FEA2LIST;

      type GEA2=structure          (* gea2 *)
            oNextEntryOffset: ULONG;     (* new field *)
            cbName: BYTE;
            szName:array[1] of CHAR;            (* new field *)
      end;
      type PGEA2=^GEA2;

      type GEA2LIST=structure      (* gea2l *)
            cbList: ULONG;
            list: array[1] of GEA2;
      end;
      type PGEA2LIST=^GEA2LIST;

      type EAOP2=structure         (* eaop2 *)
            fpGEA2List: PGEA2LIST;       (* GEA set *)
            fpFEA2List: PFEA2LIST;       (* FEA set *)
            oError: ULONG;           (* offset of FEA error *)
      end;
      type PEAOP2=^EAOP2;


      (*
      * Equates for the types of EAs that follow the convention that we have
      * established.
      *
      * Values $FFFE thru $8000 are reserved.
      * Values $0000 thru $7fff are user definable.
      * Value  $FFFC is not used
      *)

      const EAT_BINARY     = $FFFE;      (* length preceeded binary *)
      const EAT_ASCII      = $FFFD;      (* length preceeded ASCII *)
      const EAT_BITMAP     = $FFFB;      (* length preceeded bitmap *)
      const EAT_METAFILE   = $FFFA;      (* length preceeded metafile *)
      const EAT_ICON       = $FFF9;      (* length preceeded icon *)
      const EAT_EA         = $FFEE;      (* length preceeded ASCII *)
                                          (* name of associated data (#include) *)
      const EAT_MVMT       = $FFDF;      (* multi-valued, multi-typed field *)
      const EAT_MVST       = $FFDE;      (* multi-valued, single-typed field *)
      const EAT_ASN1       = $FFDD;      (* ASN.1 field *)


   (* list i/o structures  154932 *)

   type LISTIO=structure
           hFile: HFILE;          (* file handle *)
           CmdFlag: ULONG;        (* command flag *)
           Offset: LONG;         (* seek offset *)
           pBuffer: PVOID;        (* pointer to buffer *)
           NumBytes: ULONG;       (* number of bytes to r/w *)
           Actual: ULONG;         (* actual number of bytes r/w *)
           RetCode: ULONG;        (* operation return code *)
           Reserved: ULONG;       (* (internal) *)
           Reserved2: array[3] of ULONG;   (* (internal) *)
           Reserved3: array[2] of ULONG;   (* (internal) *)
   end;
   type PLISTIO=^LISTIO;

   (* Large File Support >2GB *)
   type LISTIOL=structure  (* LIO *)
           hFile: HFILE;          (* file handle *)
           CmdFlag: ULONG;        (* command flag *)
           Offset: LONGLONG;         (* seek offset *)
           pBuffer: PVOID;        (* pointer to buffer *)
           NumBytes: ULONG;       (* number of bytes to r/w *)
           Actual: ULONG;         (* actual number of bytes r/w *)
           RetCode: ULONG;        (* operation return code *)
           Reserved: ULONG;       (* (internal) *)
           Reserved2: array[3] of ULONG;   (* (internal) *)
           Reserved3: array[2] of ULONG;   (* (internal) *)
   end;
   type PLISTIOL=^LISTIOL;


function  DosOpen(pszFileName: PCSZ;
                            pHf: PHFILE;
                            pulAction: PULONG;
                            cbFile: ULONG;
                            ulAttribute: ULONG;
                            fsOpenFlags: ULONG;
                            fsOpenMode: ULONG;
                            peaop2: PEAOP2): APIRET;

   (* Large File Support > 2GB *)
function DosOpenL(  pszFileName: PCSZ;
                             phf: PHFILE;
                             pulAction: PULONG;
                             cbFile: LONGLONG;
                             ulAttribute: ULONG;
                             fsOpenFlags: ULONG;
                             fsOpenMode: ULONG;
                             peaop2: PEAOP2): APIRET;

function  DosProtectOpen(pszFileName: PCSZ;
                                    phf: PHFILE;
                                    pulAction: PULONG;
                                    cbFile: ULONG;
                                    ulAttribute: ULONG;
                                    fsOpenFlags: ULONG;
                                    fsOpenMode: ULONG;
                                    peaop2: PEAOP2;
                                    pfhFileHandleLockID: PFHLOCK): APIRET;

   (* Large File Support >2GB *)
function  DosProtectOpenL(  pszFileName: PCSZ;
                                     phf: PHFILE;
                                     pulAction: PULONG;
                                     cbFile: LONGLONG;
                                     ulAttribute: ULONG;
                                     fsOpenFlags: ULONG;
                                     fsOpenMode: ULONG;
                                     peaop2: PEAOP2;
                                     pfhFileHandleLockID: PFHLOCK): APIRET;

function  DosClose(hFile: HFILE): APIRET;

function  DosProtectClose( hFile: HFILE;
                                     fhFileHandleLockID: FHLOCK): APIRET;


function  DosRead(hFile: HFILE;
                             pBuffer: PVOID;
                             cbRead: ULONG;
                             pcbActual: PULONG): APIRET;

function  DosProtectRead( hFile: HFILE;
                                    pBuffer: PVOID;
                                    cbRead: ULONG;
                                    pcbActual: PULONG;
                                    fhFileHandleLockID: FHLOCK): APIRET;

function  DosWrite( hFile: HFILE;
                              pBuffer: PVOID;
                              cbWrite: ULONG;
                              pcbActual: PULONG): APIRET;

function  DosProtectWrite( hFile: HFILE;
                                     pBuffer: PVOID;
                                     cbWrite: ULONG;
                                     pcbActual: PULONG;
                                     fhFileHandleLockID: FHLOCK): APIRET;

function    DosListIO( ulCmdMode: ULONG;  ulNumentries: ULONG;
                                            pListIO: PLISTIO): APIRET;

   (* File time and date types *)

   type FILESTATUS=structure      (* fsts *)
        fdateCreation: FDATE;
        ftimeCreation: FTIME;
        fdateLastAccess: FDATE;
        ftimeLastAccess: FTIME;
        fdateLastWrite: FDATE;
        ftimeLastWrite: FTIME;
        cbFile: ULONG;
        cbFileAlloc: ULONG;
        attrFile: USHORT;
   end;
   type PFILESTATUS=^FILESTATUS;

   type FILESTATUS2=structure     (* fsts2 *)
        fdateCreation: FDATE;
        ftimeCreation: FTIME;
        fdateLastAccess: FDATE;
        ftimeLastAccess: FTIME;
        fdateLastWrite: FDATE;
        ftimeLastWrite: FTIME;
        cbFile: ULONG;
        cbFileAlloc: ULONG;
        attrFile: USHORT;
        cbList: ULONG;
   end;
   type PFILESTATUS2=^FILESTATUS2;

   type FILESTATUS3=structure     (* fsts3 *)
        fdateCreation: FDATE;
        ftimeCreation: FTIME;
        fdateLastAccess: FDATE;
        ftimeLastAccess: FTIME;
        fdateLastWrite: FDATE;
        ftimeLastWrite: FTIME;
        cbFile: ULONG;
        cbFileAlloc: ULONG;
        attrFile: ULONG;
   end;
   type PFILESTATUS3=^FILESTATUS3;

   type FILESTATUS4=structure      (* fsts4 *)
        fdateCreation: FDATE;
        ftimeCreation: FTIME;
        fdateLastAccess: FDATE;
        ftimeLastAccess: FTIME;
        fdateLastWrite: FDATE;
        ftimeLastWrite: FTIME;
        cbFile: ULONG;
        cbFileAlloc: ULONG;
        attrFile: ULONG;
        cbList: ULONG;
   end;
   type PFILESTATUS4=^FILESTATUS4;


   (* Large File Support >2GB *)
   type FILESTATUS3L=structure     (* fsts3L *)
          fdateCreation: FDATE;
          ftimeCreation: FTIME;
          fdateLastAccess: FDATE;
          ftimeLastAccess: FTIME;
          fdateLastWrite: FDATE;
          ftimeLastWrite: FTIME;
          cbFile: LONGLONG;
          cbFileAlloc: LONGLONG;
          attrFile: ULONG;
   end;
   type PFILESTATUS3L=^FILESTATUS3L;

   (* Large File Support >2GB *)
   type FILESTATUS4L=structure      (* fsts4L *)
          fdateCreation: FDATE;
          ftimeCreation: FTIME;
          fdateLastAccess: FDATE;
          ftimeLastAccess: FTIME;
          fdateLastWrite: FDATE;
          ftimeLastWrite: FTIME;
          cbFile: LONGLONG;
          cbFileAlloc: LONGLONG;
          attrFile: ULONG;
          cbList: ULONG;
   end;
   type PFILESTATUS4L=^FILESTATUS4L;


   type FSALLOCATE=structure      (* fsalloc *)
        idFileSystem: ULONG;
        cSectorUnit: ULONG;
        cUnit: ULONG;
        cUnitAvail: ULONG;
        cbSector: USHORT;
   end;
   type PFSALLOCATE=^FSALLOCATE;

   type  HDIR=LHANDLE;        (* hdir *)
   type PHDIR=^HDIR;

(*
   const DosOpen2        DosOpen
   const DosFindFirst2   DosFindFirst
   const DosQFHandState  DosQueryFHState
   const DosProtectQFHandState  DosProtectQueryFHState
   const DosSetFHandState  DosSetFHState
   const DosProtectSetFHandState  DosProtectSetFHState
   const DosQHandType    DosQueryHType
   const DosQFSAttach    DosQueryFSAttach
   const DosNewSize      DosSetFileSize
   const DosProtectNewSize  DosProtectSetFileSize
   const DosBufReset     DosResetBuffer
   const DosChgFilePtr   DosSetFilePtr
   const DosProtectChgFilePtr   DosProtectSetFilePtr
   const DosMkDir        DosCreateDir
   const DosMkDir2       DosCreateDir
   const DosRmDir        DosDeleteDir
   const DosSelectDisk   DosSetDefaultDisk
   const DosQCurDisk     DosQueryCurrentDisk
   const DosChDir        DosSetCurrentDir
   const DosQCurDir      DosQueryCurrentDir
   const DosQFSInfo      DosQueryFSInfo
   const DosQVerify      DosQueryVerify
   const DosQFileInfo    DosQueryFileInfo
   const DosProtectQFileInfo    DosProtectQueryFileInfo
   const DosQPathInfo    DosQueryPathInfo
*)

function  DosDelete(pszFile: PCSZ): APIRET;

function  DosForceDelete(pszFile: PCSZ): APIRET;

function  DosDupHandle( hFile: HFILE;
                                  pHfile: PHFILE): APIRET;

function  DosQueryFHState( hFile: HFILE;
                                     pMode: PULONG): APIRET;

function  DosProtectQueryFHState( hFile: HFILE;
                                            pMode: PULONG;
                                            fhFileHandleLockID: FHLOCK): APIRET;

function  DosSetFHState( hFile: HFILE;
                                   mode: ULONG): APIRET;

function  DosProtectSetFHState( hFile: HFILE;
                                          mode: ULONG;
                                          fhFileHandleLockID: FHLOCK): APIRET;

function  DosQueryHType( hFile: HFILE;
                                   pType: PULONG;
                                   pAttr: PULONG): APIRET;

function  DosFindFirst(     pszFileSpec: PCSZ;
                                   phdir: PHDIR;
                                   flAttribute: ULONG;
                                   pfindbuf: PVOID;
                                   cbBuf: ULONG;
                                  pcFileNames: PULONG;
                                   ulInfoLevel: ULONG): APIRET;

function  DosFindNext(   hDir: HDIR;
                                  pfindbuf: PVOID;
                                  cbfindbuf: ULONG;
                                 pcFilenames: PULONG): APIRET;

function  DosFindClose( hDir: HDIR): APIRET;

function  DosFSAttach(  pszDevice: PCSZ;
                                  pszFilesystem: PCSZ;
                                 pData: PVOID;
                                 cbData: ULONG;
                                 flag: ULONG): APIRET;

function  DosQueryFSAttach(     pszDeviceName: PCSZ;
                                       ulOrdinal: ULONG;
                                       ulFSAInfoLevel: ULONG;
                                      pfsqb: PFSQBUFFER2;
                                      pcbBuffLength: PULONG): APIRET;

function  DosFSCtl( pData: PVOID;
                              cbData: ULONG;
                              pcbData: PULONG;
                              pParms: PVOID;
                              cbParms: ULONG;
                              pcbParms: PULONG;
                              xfunction: ULONG;
                              pszRoute: PCSZ;
                              hFile: HFILE;
                              method: ULONG): APIRET;

function  DosSetFileSize( hFile: HFILE;
                                    cbSize: ULONG): APIRET;

   (* Large File Support >2GB *)
function  DosSetFileSizeL( hFile: HFILE;
                                     cbSize: LONGLONG): APIRET;

function  DosProtectSetFileSize( hFile: HFILE;
                                           cbSize: ULONG;
                                           fhFileHandleLockID: FHLOCK): APIRET;

   (* Large File Support >2GB *)
function   DosProtectSetFileSizeL( hFile:HFILE;
                                             cbSize: LONGLONG;
                                             fhFileHandleLockID: FHLOCK): APIRET;

function  DosResetBuffer(hFile: HFILE): APIRET;

function  DosSetFilePtr( hFile: HFILE;
                                   ib: LONG;
                                   method: ULONG;
                                   ibActual: PULONG): APIRET;

   (* Large File Support >2GB *)
function  DosSetFilePtrL( hFile: HFILE;
                                    ib:LONGLONG;
                                    method:ULONG;
                                    ibActual: PLONGLONG): APIRET;

function  DosProtectSetFilePtr(hFile: HFILE;
                                          ib: LONG;
                                          method:ULONG;
                                          ibActual:PULONG;
                                          fhFileHandleLockID:FHLOCK): APIRET;

   (* Large File Support >2GB *)
function  DosProtectSetFilePtrL( hFile:HFILE;
                                           ib:LONGLONG;
                                           method:ULONG;
                                           ibActual:PLONGLONG;
                                           fhFileHandleLockID:FHLOCK): APIRET;

   (* Large File Support >2GB *)
function  DosListIOL( CmdMODE:LONG;
                                NumEntries:LONG;
                                pListIO: PLISTIO): APIRET;

function  DosMove(  pszOld: PCSZ;
                              pszNew: PCSZ): APIRET;

function  DosCopy(  pszOld: PCSZ;
                              pszNew: PCSZ;
                             option: ULONG): APIRET;

function  DosEditName( metalevel: ULONG;
                                  pszSource: PCSZ;
                                  pszEdit: PCSZ;
                                 pszTarget: PBYTE;
                                 cbTarget:ULONG): APIRET;

function  DosCreateDir(  pszDirName: PCSZ;
                                  peaop2:PEAOP2): APIRET;

function  DosDeleteDir(  pszDir:PCSZ): APIRET;

function  DosSetDefaultDisk( disknum:ULONG): APIRET;

function  DosQueryCurrentDisk( pdisknum: PULONG;
                                         plogical:PULONG): APIRET;

function  DosSetCurrentDir(  pszDir:PCSZ): APIRET;

function  DosQueryCurrentDir( disknum:ULONG;
                                        pBuf:PBYTE;
                                        pcbBuf:PULONG): APIRET;

function  DosQueryFSInfo( disknum:ULONG;
                                    infolevel:ULONG;
                                    pBuf:PVOID;
                                    cbBuf:ULONG): APIRET;

function  DosSetFSInfo( disknum:ULONG;
                                  infolevel:ULONG;
                                  pBuf:PVOID;
                                  cbBuf:ULONG): APIRET;

function  DosQueryVerify( pBool:PBOOL32): APIRET;

function  DosSetVerify(vstate:BOOL32): APIRET;

function  DosSetMaxFH( cFH:ULONG): APIRET;

function  DosSetRelMaxFH( pcbReqCount:PLONG;
                                    pcbCurMaxFH:PULONG): APIRET;

function  DosQueryFileInfo( hf:HFILE;
                                      ulInfoLevel:ULONG;
                                      pInfo:PVOID;
                                      cbInfoBuf:ULONG): APIRET;

function  DosProtectQueryFileInfo( hf:HFILE;
                                             ulInfoLevel:ULONG;
                                             pInfo:PVOID;
                                             cbInfoBuf:ULONG;
                                             fhFileHandleLockID:FHLOCK): APIRET;

function  DosSetFileInfo( hf:HFILE;
                                    ulInfoLevel:ULONG;
                                    pInfoBuf:PVOID;
                                    cbInfoBuf:ULONG): APIRET;

function  DosProtectSetFileInfo( hf:HFILE;
                                           ulInfoLevel:ULONG;
                                           pInfoBuf:PVOID;
                                           cbInfoBuf:ULONG;
                                           fhFileHandleLockID:FHLOCK): APIRET;

function  DosQueryPathInfo(    pszPathName:PCSZ;
                                      ulInfoLevel:ULONG;
                                      pInfoBuf:PVOID;
                                      cbInfoBuf:ULONG): APIRET;

function  DosSetPathInfo(    pszPathName:PCSZ;
                                    ulInfoLevel:ULONG;
                                    pInfoBuf:PVOID;
                                    cbInfoBuf:ULONG;
                                    flOptions:ULONG): APIRET;

   (* defines for DosSetPathInfo -pathinfo flag *)
   const DSPI_WRTTHRU   = $10;    (* write through *)

function  DosShutdown( ulReserved:ULONG): APIRET;

function  DosEnumAttribute(  ulRefType:ULONG;
                                       pvFile:PVOID;
                                       ulEntry:ULONG;
                                       pvBuf:PVOID;
                                       cbBuf:ULONG;
                                       pulCount:PULONG;
                                       ulInfoLevel:ULONG): APIRET;

function  DosProtectEnumAttribute( ulRefType:ULONG;
                                             pvFile:PVOID;
                                             ulEntry:ULONG;
                                             pvBuf:PVOID;
                                             cbBuf:ULONG;
                                             pulCount:PULONG;
                                             ulInfoLevel:ULONG;
                                             fhFileHandleLockID:FHLOCK ): APIRET;


   type DENA1=structure (* _dena1 level 1 info returned from DosEnumAttribute *)
             reserved:UCHAR;       (* 0 *)
             cbName:UCHAR;         (* length of name exculding NULL *)
             cbValue:USHORT;        (* length of value *)
             szName:array[1] of UCHAR;      (* variable length asciiz name *)
   end;
   type PDENA1=^DENA1;

   type   DENA2=FEA2;
   type  PDENA2=PFEA2;

   (* Infolevels for DosEnumAttribute  *)
   const ENUMEA_LEVEL_NO_VALUE  = 1;      (* FEA without value *)
   (* Reference types for DosEnumAttribute *)
   const ENUMEA_REFTYPE_FHANDLE = 0;       (* file handle *)
   const ENUMEA_REFTYPE_PATH    = 1;       (* path name *)
   const ENUMEA_REFTYPE_MAX     = ENUMEA_REFTYPE_PATH;

end.

